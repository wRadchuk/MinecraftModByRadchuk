package com.minecraft.mod.by.radchuk.custom_entities;

import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.ai.goal.*;
import net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal;
import net.minecraft.world.entity.monster.Monster;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.NotNull;

/**
 * Класс пользовательской сущности-моба гуманоидного типа.
 * <p>
 * Этот класс представляет собой реализацию враждебного моба, который имеет
 * гуманоидную форму и поведение. Моб наследуется от базового класса {@link Monster}
 * из Minecraft, что дает ему стандартные характеристики враждебных мобов.
 * <p>
 * Основные особенности моба:
 * <ul>
 *   <li>Атакует игроков в ближнем бою</li>
 *   <li>Случайно перемещается по миру, избегая воды</li>
 *   <li>Следит за игроками и реагирует на их присутствие</li>
 *   <li>Не исчезает со временем (persistent)</li>
 *   <li>Может быть привязан на поводок</li>
 * </ul>
 * <p>
 * Моб использует систему целей (goals) Minecraft для определения своего поведения,
 * что позволяет ему принимать решения на основе окружающей среды и присутствия игроков.
 */
public class CustomHumanMob extends Monster {

    /** Логгер для вывода отладочной информации о поведении моба */
    private static final Logger LOGGER = LogManager.getLogger();

    /**
     * Конструктор сущности.
     * <p>
     * Создает новый экземпляр моба с указанным типом и в указанном мире.
     * Устанавливает флаг persistenceRequired, чтобы предотвратить естественный деспавн.
     *
     * @param entityType тип сущности, определяющий базовые характеристики
     * @param level мир (уровень), в котором находится сущность
     */
    public CustomHumanMob(EntityType<? extends Monster> entityType, Level level) {
        super(entityType, level);
        this.setPersistenceRequired(); // Предотвращает естественный деспавн
    }

    /**
     * Регистрирует цели поведения сущности.
     * <p>
     * Этот метод определяет, что сущность будет делать в различных ситуациях.
     * Цели добавляются с приоритетами (меньшее число = более высокий приоритет).
     * <p>
     * Включает следующие цели:
     * <ul>
     *   <li>Плавание при попадании в воду</li>
     *   <li>Атака в ближнем бою</li>
     *   <li>Случайное перемещение с избеганием воды</li>
     *   <li>Наблюдение за игроками</li>
     *   <li>Случайный осмотр окружения</li>
     *   <li>Выбор ближайшего игрока как цели для атаки</li>
     * </ul>
     */
    @Override
    protected void registerGoals() {
        // Базовые цели поведения
        this.goalSelector.addGoal(0, new FloatGoal(this)); // Плавать, если в воде (высший приоритет)
        this.goalSelector.addGoal(1, new MeleeAttackGoal(this, 1.0D, true)); // Атака в ближнем бою со скоростью 1.0
        this.goalSelector.addGoal(1, new WaterAvoidingRandomStrollGoal(this, 1.0D)); // Случайно бродить, избегая воды
        this.goalSelector.addGoal(2, new LookAtPlayerGoal(this, Player.class, 8.0F)); // Смотреть на игрока в радиусе 8 блоков
        this.goalSelector.addGoal(3, new RandomLookAroundGoal(this)); // Случайно осматриваться

        // Цели выбора целей для атаки
        this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, true)); // Атаковать ближайшего игрока
    }

    /**
     * Определяет, может ли моб быть привязан на поводок.
     * <p>
     * В отличие от большинства враждебных мобов, этот моб может быть привязан
     * на поводок любым игроком.
     *
     * @param player игрок, пытающийся привязать моба
     * @return true, указывая что моб может быть привязан
     */
    @Override
    public boolean canBeLeashed(@NotNull Player player) {
        return true; // Позволяет игрокам привязывать моба на поводок
    }

    /**
     * Вызывается при каждом тике сущности.
     * <p>
     * Этот метод выполняется каждый игровой тик (1/20 секунды) и может
     * использоваться для добавления дополнительной логики поведения,
     * которая должна выполняться постоянно.
     * <p>
     * В текущей реализации просто вызывает родительский метод, но может
     * быть расширен для добавления специфического поведения.
     */
    @Override
    public void tick() {
        super.tick();
        // Здесь можно добавить дополнительную логику, выполняемую каждый тик
        // Например: проверка окружения, создание частиц, специальные действия и т.д.
    }

    /**
     * Вызывается при получении урона сущностью.
     * <p>
     * Этот метод позволяет реализовать специальную логику реакции на урон,
     * например, создание эффектов, звуков или изменение поведения.
     * <p>
     * В текущей реализации просто передает обработку родительскому классу,
     * но может быть расширен для добавления специфических реакций на урон.
     *
     * @param source источник урона (огонь, падение, атака и т.д.)
     * @param amount количество урона
     * @return true, если урон был успешно применен
     */
    @Override
    public boolean hurt(@NotNull net.minecraft.world.damagesource.DamageSource source, float amount) {
        // Можно добавить специальную логику при получении урона
        // Например: создание эффектов, звуков, призыв подкрепления и т.д.
        return super.hurt(source, amount);
    }

    /**
     * Вызывается при смерти сущности.
     * <p>
     * Этот метод позволяет реализовать специальную логику при смерти моба,
     * например, создание эффектов, выпадение особых предметов или вызов событий.
     * <p>
     * В текущей реализации просто вызывает родительский метод, но может
     * быть расширен для добавления специфических действий при смерти.
     *
     * @param source источник урона, вызвавший смерть
     */
    @Override
    public void die(@NotNull net.minecraft.world.damagesource.DamageSource source) {
        super.die(source);
        // Здесь можно добавить специальную логику при смерти
        // Например: создание взрыва, выпадение особых предметов, спавн других мобов и т.д.
    }

    /**
     * Определяет, может ли сущность издавать звуки.
     * <p>
     * Если вернуть true, моб будет издавать стандартные звуки монстров.
     * Если вернуть false, моб будет бесшумным.
     *
     * @return false, если моб должен быть бесшумным, иначе true
     */
    @Override
    public boolean isSilent() {
        return false; // По умолчанию моб издает звуки
    }

    /**
     * Определяет, может ли сущность быть затронута эффектами зелий.
     * <p>
     * Этот метод позволяет контролировать, какие эффекты зелий могут
     * воздействовать на моба. Можно реализовать иммунитет к определенным
     * эффектам или полностью запретить воздействие зелий.
     * <p>
     * В текущей реализации просто вызывает родительский метод, позволяя
     * всем эффектам воздействовать на моба стандартным образом.
     *
     * @param effectInstance экземпляр эффекта зелья
     * @return true, если эффект может воздействовать на моба
     */
    @Override
    public boolean canBeAffected(@NotNull net.minecraft.world.effect.MobEffectInstance effectInstance) {
        // Можно добавить проверку типа эффекта и вернуть false для определенных эффектов,
        // чтобы сделать моба иммунным к ним
        return super.canBeAffected(effectInstance);
    }
}
